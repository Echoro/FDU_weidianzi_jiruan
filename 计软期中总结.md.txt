# 第一章：

## 操作系统

### **操作系统的作用：**

用户与计算机(硬件与软件)的中介人(界面，接口，管理员)

对用户而言 通过OS来使用计算机的软硬件资源，操作简便亲和。 

对计算机和管理人员而言 通过OS来面对用户的要求，合理组织计算机的工作流程，充分利用和发挥计算机的软硬件资源， 提高计算机的效率。



### **操作系统的特征** ：

操作系统具有四个基本特征：并发，共享，虚拟，不确定性。

**并发**是指操作系统具有**管控同时运行多个用户任务的能力**，其特征可**改善系统资源的利用率和 提高系统的吞吐量**

**共享**是指计算机中的**软硬件资源可供多个进程共同使用**，而不被独占。可有**互斥共享和同时访问两种共享方式**

**虚拟**是指把一个**物理实体变为若干个逻辑上的对应物**。前者是实的，是实际存在的；而后者是 虚的，只是用户的一种感觉。

多个进程运行时，只要运行环境相同，输入信息相同，运行结果也相同，而各自的**启动时间、 运行顺序和运行时间的不确定性**是必然的，也是允许的。

![image-20240507115732829](.\image\image-20240507115732829.png)

![image-20240507115751052](.\image\image-20240507115751052.png)

DOS  Gary Kildall(加里• 基尔代尔)最早创造了磁盘操作系统(DOS)。

1981年，IBM公司推出MS-DOS 1.0(Microsoft Disk Operating System)操作系统。 1985年，Bill  Gates发布了Microsoft Windows 1.0，成为全世界家喻户晓的微机操作系统，并终结了MS-DOS。

### **操作系统的分类：**

按功能分类，操作系统大体可以分为**过程控制OS，信息查询OS，事务处理OS，批处理OS和 分时OS五类**。本课程主要从功能分类介绍操作系统。其中，**分时OS为重点**

![image-20240507120521035](.\image\image-20240507120521035.png)

#### **实时操作系统**

要求对随机发生的外部事件能够给出及时的响应，随时采集现场信息，在限定时间内给出处理。 

特点：   及时性强 高可靠性 简单的交互性



大概了解，知道怎么分类就行

![image-20240507120740486](.\image\image-20240507120740486.png)

#### **作业处理操作系统：**

作业处理OS可以分为两类：**批处理OS和分时OS**。 

特点：以用户提交的作业为处理对象, 没有严格的时间响应限制； **允许多个用户同时运行多个作业**；合理安排用户作业在系统运行, 提高计算机效率； **及时性弱， 交互性强**。 



##### 作业处理操作系统中的两个重要概念：作业和进程

**作业(Task/Job)** ： 用户设计的**可在计算机中运行的程序单位称为作业**，一段**源程序经编译后成为作业**

![image-20240507121002604](.\image\image-20240507121002604.png)

**进程(Process)  ：**  **处于运行状态的作业称为进程**，一个作业可以被多次运行，由此将产生多个进程，分别处于不同的状态。

一个进程 可以有三种状态(status)，即**就绪状态   执行状态   封锁状态**。

![image-20240507121310774](.\image\image-20240507121310774.png)

**就绪状态**(ready) ：各种条件均已准备完毕，等待占有CPU而执行进程。 

**执行状态**：占有CPU，执行作业中规定的指令。 

**封锁状态**(block)  由于某种原因，无法占有CPU而处于封锁状态，例如要进行I/O操作等



**进程管理：**

**装入内存：**<u>作业进入运行阶段</u>，创建进程，并且处于就绪状态。 

**调入(就绪→执行)：**进程被选中，占有CPU，执行进程。 

**剥夺(执行→就绪)：**进程执行的时限到，回到就绪状态，回到就绪状态，等待下一次调入。 

**封锁(执行→封锁)：**由于 **执行进程的条件不能满足或 者等待某个事件**，例如需要转 到执行I/O操作，由执行状态 转到封锁状态。 

**解除封锁 (封锁→就绪)：**封锁条件已解 除，转到就绪状态，等待调入。 

**结束：**进程执行完毕，退出内存，转入僵死状态，<u>作业进入完成阶段</u>。

![image-20240507121734068](.\image\image-20240507121734068.png)



##### 作业和进程的关系

 在**单道程序**的批处理OS中，<u>作业和进程是一一对应的</u>，作业调度和进程调度可不加区分。 

在**多道程序**的作业处理OS中，<u>作业调度和进程调度是两个概念</u>，一个作业可分别产生多个进程， 而多个用户又可同时提交各种相同或不相同的作业。 

**进程控制块**(Process Control Block，PCB，或称PCB表)  ：

**作业和进程的一个重要区别在于作业是静态的,而进程是动态的**。 <u>作业的静态表现</u>为作业由目标文件、数据和运行命令所组成，它们**在作业的各个阶段，内容是 不变的**。 当一个**作业开始运行时**，系统将创建一个进程，并且加上一个进程控制块，也就是说**进程等于 作业加进程控制块**。一个作业每运行一次，就可以创建一个进程，因此一个作业可以创建多个进程。 **进程控制块用于记录进程的各种特性**，包括作业名，进程名，优先级，进程处于何种状态，进 程占有资源的情况等。 由于进程控制块的作用不仅仅用来识别进程，其内容是在不断变化的，<u>因此称进程是动态的</u>。



##### 进程和线程的关系

**进程是拥有资源的独立单位，也是独立调度和分派的独立单位**。

在多处理机系统中，建立了**可独立调度和分派的线程**(Threads)，可**以将不同的线程安排在不同的 处理机上并行执行。**

线程能够独立运行，具有独立的线程控制块(Threads Control Block，TCB)。与进程一样可处于就绪、执行和封锁三种状态。 

进程：可称为重型进程(Heavy-Weight Process)。 

线程：可称为轻型进程(Light-Weight Process)。

**线程的切换明显快于进程**。在**同一个进程下切换线程，不会引起进程的切换**。例如，在文字处理器的进程中可以创建图文显示、读入数据以及进行拼写和语法检查三个线程。在网络浏览器的进程中可以创建图文显示和接受数据两个线程。

（一个进程可以产生多个线程）



##### 批处理操作系统

**基本特性：**

**接受一系列用户提交的作业，形成后备作业流**；根据某种作业调度算法，将后备作业逐个调入内存运行，待运行结束，交给用户。 

在**提交作业后到作业完成之间，用户无法干预作业的运行**，即使在用户已知出错的情况下也难以中止。就象批改学生的作业本或者考卷。

**特点 ：**

优点：作业控制的自动化程度高，资源分配合理，高吞吐率，高利用率

缺点：不易干预



##### 分时操作系统(Time Sharing OS，分时 OS) 

**基本特性** 

将CPU运行的**时间分成若干个时间片**，例如一秒钟分成几十或者几百个时间片(tick)，**各进程轮流使用CPU**。当一个进程在CPU中的时间片时限已到，则不管其是否要等待I/O，还是可以继续 占有CPU，都将转换到就绪状态，让位给另一个进程。由于计算机的速度足够快，可以使每个进程的用户感觉不到进程有间歇的时间。

**分时系统的三大特点：** 

**多路性**： 宏观上讲，**可以有多个进程同时在CPU中执行**，即有多个用户在同时使用计算机。 **交互性**： 用户可随时进行**交互操作，包括中止**。 **独占性**： 用户总觉得似乎只有他一人在使用计算机



###  Linux 操作系统的特点 

#### (1) 结构合理，精巧简洁。

在结构上分为**核心(Kernel)和外围(Shell)两部分**，有机结合。核心程序仅 占用很小的空间而常驻内存，以保证系统的高效率运行。用户通过shell来使用计算机。

![image-20240507123933882](.\image\image-20240507123933882.png)

#### (2) 安全可靠。

在**多用户的环境**中，凡是对安全性和可靠性有较高要求的应用软件，都选择Linux系统作为开发和运行的平台。

#### (3) 设备无关性。

将**所有文件、文件目录和外部设备设置相同的语法语义和相同的保护机制**，便于 应用软件的开发和使用。

#### (4) 高可扩展性、可维护性与良好的可移植性。

Linux的**绝大部分程序用C语言编程，汇编程序只占 约5%**，因此易于理解、修改、扩充和移植，使其成为工业主流的主要原因之一。

#### (5) 开放性和优异的网络性能。

**遵循世界标准规范，符合TCP/IP网络协议**，在通讯和网络功能方面 明显优于其他操作系统。





### 操作系统管理的内容

硬件资源： CPU, Memory, Storage, I/O  

软件资源： OS 本身，系统实用程序及应用软件等，用户的程序及数据 (均以文件方 式存放在软硬盘等介质之中) 

### 操作系统的功能模块（重要！）

进程管理模块(处理机和进程管理模块)  

存储器管理模块 

设备管理模块 

信息管理模块(文件管理模块，文件系统)  

用户界面(用户接口) 



#### 处理机和进程管理模块

##### **作业的生成**

用某种程序设计语言(例如C语言)编写的源文件(源程序)，经过编译，将生成二进制格式 的可执行文件(Executive file)。每个可执行文件对应于一个作业。

<u>包括链接在内的编译过程 称为</u>**广义的编译**。

<u>从源文件到目标文件的生成过程称为</u>**狭义的编译**。通常，不会混淆这两个编译。



##### **作业调度**

选择某个**作业进入运行阶段**，给其分配内存和其他软硬件资源。将完成的作业撤出内存 等等。 **被选中的作业将调入内存并创建相应的进程交给进程调度管理**。

因此，**作业调度又可称为宏观调度**



##### 进程调度

###### **进程调度的任务**

创建一个进程，首先建立一个进程控制块(PCB，Process Control Block)。 如何**控制一个进程在运行阶段的三种状态间合理地转换**，以便充分利用CPU以及其他 软硬件资源。

###### 进程分类以及设定进程优先级

系统进程—核心态(特权进程)  用户进程—用户态(普通进程)  **系统进程比用户进程的优先级高**

###### 进程优先级的控制

显示或改变进程的优先级，<u>例如ps命令和nice命令</u>。

###### 动态优先的进程调度算法

根据占有 CPU 的时间来动态改变优先级，可使各进程的响应时间较均匀。

###### 扩展执行状态的进程调度

如果**用户进程需要调用系统进程**，则转入核心态执行，直至核心态执行结束才返回用户态执行。 

如果**发现有优先级高于用户进程的其他进程**，则该进程被中断，<u>转入</u><u>中断状态，直至中 断结束</u>才返回用户态执行。

由此，执行状态被细分为**用户态执行、核心态执行和中断执行**三个状态。 增加进程转换操作。

系统调用： 用户态执行→核心态执行 

系统返回： 核心态执行→用户态执行 

中断： 用户态执行→中断执行 

中断返回： 中断执行→用户态执行

![image-20240507125428291](.\image\image-20240507125428291.png)

#### 存储管理模块

##### 存储器管理模块的功能

用于**确保所有进程都能安全访问存储区**。同时，Linux支持虚拟内存管理方式，从而可 以使用比内存更多的存储空间。



##### 存储器管理模块的主要任务

<u>存储分配、地址映射和内存保护。</u>



###### 存储分配

**存储管理模块的功能**是根据程序所需要的**逻辑空间**，在内存中**为其分配相应的物理空间**。

可执行文件描述了程序在运行时所需要的内存大小，及其以首地址为0的逻辑地址。所 占内存包括**代码区(code)和数据区(data)**。

![image-20240507130004107](.\image\image-20240507130004107.png)

**数据区由DATA段和BSS段组成**，存放的是<u>静态数据</u>。

程序中定义的数据包括动态数据和静态数据。例如C语言中的<u>局部变量和寄存器变量</u>属于**动态数据**，<u>全局变量和静态变量</u>属于**静态数据**。 **DATA称为固定数据段，**包括在程序中<u>定义的常量和已赋初值的静态数据</u>，在可执行文 件中占有相应的存储空间。 **BSS(Block Started by Symbol)称为未初始化数据段。**在可<u>执行文件中仅描述了所需存储空间的大小。</u>



可执行文件(内存映象文件)只是描述了一个程序所需的内存大小，**可执行文件的字节数通 常不大于所需内存的大小。**（ls -s和size重要）

![image-20240507130837472](.\image\image-20240507130837472.png)

**虚拟存储的技术用来将部分外存储器作为虚拟的内存储器**，从而使得作业的存储空间可以 扩大许多倍。



###### 地址映射

可执行文件的首地址将映射为内存中的偏移量(offset)。 可执行文件的所有逻辑地址加上偏移量，将转换为内存中的物理地址。**逻辑地址到物理 地址的转换工作称为地址映射**



###### 内存保护

内存保护的**任务是保护每个进程的合法地址，限制进程访问其不能访问的非法地址**。一 旦遇到非法访问，内存保护的任务就要拒绝访问，并进行出错处理。

<u>如果**调用系统函数**，内存保护模块认为这是合法的转移执行，而不是非法访问。</u> 

如果进程在其合法空间内**到数据区取指令，或者到代码区取数据**的话，必将发生错误

![image-20240507131326633](.\image\image-20240507131326633.png)



##### 采用虚拟存储技术的进程调度

进程的**就绪状态**将分解为内存就绪和外存就绪两个状态。 

进程的**封锁状态**将分解为内存封锁和外存封锁两个状态。

![image-20240507131420488](.\image\image-20240507131420488.png)

1）增加状态-装入外存：创建进程后在外存中就绪。 

2）增加操作-就绪换入：外存中就绪→内存中就绪。 

3）增加操作-就绪换出：内存中就绪→外存中就绪。 

4）增加操作-封锁换出：内存中封锁→外存中封锁。

5）解除封锁改为内存解除封锁：内存中封锁→内存中就绪。 

6）增加操作-外存解除封锁：外存中封锁→外存中就绪。



#### 设备管理模块 

##### 设备管理模块的**管理对象** ：

**文件的存储介质**： 硬盘，软盘，磁带，光盘、U盘等  **I/O设备**： 字符终端，图形终端，打印机，绘图仪等 **专用I/O设备**： 数据采集仪，扫描仪，图像摄入装置，音频I/O设备等

##### 设备管理模块的**任务** ：

**为用户(作业/进程)提供使用设备的界面**，根据设备的性能设计不同的驱动程序(driver) 去驱动这些设备(drive)。 **设计一定的分配策略**，根据对设备的申请，合理分配这些资源，完成数据的传递和I/O 操作，以提高系统的效率。

##### Linux设备分类 

Linux 把设备分为**块设备**和**字符设备**两类。

###### **块设备**

块设备是指各种文件存储介质。**块设备以块(block)为单位成批传送数据，速度快，属于 可以同时访问的共享设备**。 可用**随机存取(直接存取)和顺序存取**两种方式来访问块设备。

 (1) **随机存取**块设备，是指将某个命名为设备文件的逻辑盘区视为一个可装卸的文件子 系统。

访问前要用 **mount 命令将块设备装配到某个目录**下，然后就可以通过文件系统的子目 录，直接访问块设备中的文件

(2) **顺序存取**块设备，一般用作于文件的转储备份，则在块设备中不含目录结构，只有 数据的顺序。**这类设备的存取不必装配**。Linux 系统**最常用的转储命令是 tar 命令和 dd 命 令**

![image-20240507215148524](.\image\image-20240507215148524.png)

###### 字符设备

字符设备**通常指用于数据的 I/O 设备**，例如终端设备，打印机等。 

**数据按字符传输，速度慢。** 字符设备称为**独占性设备，不能有多个进程同时访问，而是按照先后顺序给予访问。**

#### 文件系统

**定义**：Linux系统把文件定义为一个没有记录结构的字符流。**所有的文件在计算机中形成一个 文件系统(file system)。** 

文件系统(信息管理模块，或者文件管理模块)的**任务**是管理这个文件系统。

<u>建立文件 的存储检索；管理文件的空间分配；建立文件的共享和保护等机制；对用户提供文件操作的 界面</u>。



##### Linux的标准目录结构

/bin 二进制(可执行文件)目录 

/etc 系统杂类文件目录

/dev 设备文件目录 

/lib 库函数目录  

/tmp 临时文件目录  

/usr 客户的系统文件目录 

/usr/bin    /usr/etc    /usr/lib ... 客户系统文件的有关目录 

/users 用户目录 

/home 用户注册目录的父目录



##### 文件分类

Linux 将**普通文件、目录、设备**等**统一用文件**来管理

**普通文件**(file，或plain file)  普通文件，简称文件，存放 **ASCII 或者 Binary 等各类数据**。 例如：.profile，a.txt，a.out，/tmp/core，等等。 

**目录文件**(directory)  目录也是一个文件，即目录文件。**记录该目录下的文件信息，包括文件名称、大小、所 有者、访问权限、创建和修改时间、文件链接信息，以及该目录下文件的总数和总容量等等**。 例如：/bin，/etc，/dev，/usr/bin，/usr/etc，等等 

**设备文件**(device)  设备文件(device)及其他一些特殊用途的文件。 例如：/dev/fd0(硬盘)，/dev/mem(内存)，/dev/null(空设备，垃圾筒，空目录), 等等。 如果将文件或者目录移到/dev/null 下，相当于删除文件或者目录。

![image-20240507215953622](.\image\image-20240507215953622.png)

首字符为.的文件称为隐含文件，必须用 ls -a 显示其信息。



##### 文件保护模式

用户(user)分类 

u：user(owner) 文件主人 

g：group 与文件主人同组的用户 

o：others 与文件主人不同组的其他用户 

a：all 以上全部用户

访问类型(access)分类 

r：read 表示有权读取文件，有权列表(查看)目录，或者**有权从设备上获取信息**。 （对应于三种文件分类）

w：write 表示有权修改文件，有权在目录中创建或者删除文件和文件，或者**有 权向设备输出信息**。 

e：executable 表示有权执行文件，或者有权访问该目录。需要注意的是，**有权执行文件还需依赖于文件确定是可执行的。** 

-：no right 表示无权访问。



##### 文件系统的符号链接

![image-20240507220525371](.\image\image-20240507220525371.png)



##### 网络文件系统

网络文件系统(networking file system，NFS)，是**管理处于网络中不同物理位置的计算 机(称为宿主机，host)的文件系统。**

每台宿主机都可以拥有各自的多个物理盘区，通常以硬盘为主要的物理盘区。 

每个物理盘区可以划分为多个分区，各自对应一个逻辑盘区。

![image-20240507220928908](.\image\image-20240507220928908.png)

![image-20240507220936177](.\image\image-20240507220936177.png)



#### 用户接口

用户界面(user interface)又称为用户接口。 Linux 的用户可以**通过 shell 和系统调用两种界面**使用操作系统

##### shell

Linux的shell是多功能的用户界面。 

 shell是**命令语言**(command language)。 Linux提供了丰富的shell命令。

 shell是**编程语言**(progamming language) 。 可用来编写shell程序(又称为脚本)，包括定义变量，使用控制结构等。 

 shell是**解释性程序**(解释器，interpreter)。 用户登录Linux后，shell程序就开始启动并且负责解释和执行用户用交互方式提交的命 令、系统程序和用户程序。

![image-20240507221158925](.\image\image-20240507221158925.png)

##### 系统调用

系统调用是指 Linux 提供的系统函数。

 对用户而言，**系统调用**和**库函数的使用**形式都是函数调用，但实质上两者是**有所区别** 的。



系统调用属于操作系统核心的一个组成部分，并且**常驻内存**。 

库函数保存在文件系统中，**运行时才装载到内存**。 

系统调用在目标代码中仅表现为一条转移指令，以**核心态运行**，速度快。 

库函数在可执行文件中。以**用户态运行**，速度要慢些。 

系统调用的**种类、数量和功能固定**，不能改变和扩充。

库函数由操作系统或者用户自己编制，**可随时增减和修改**。



### shell简述

![image-20240507222521020](.\image\image-20240507222521020.png)

![image-20240507222532950](.\image\image-20240507222532950.png)

可使用man命令查阅用户手册。





## Linux Shell

### Shell命令

#### 输入输出定向

Linux定义了三个标准的输入输出定向，并且可以改变它们的定向。

(1) 标准输入(stdin)，缺省值为键盘输入。 stdin的来源：shell的read语句，C语言的scanf()等。

(2) 标准输出(stdout)，缺省值为屏幕显示。 stdout的来源：shell的echo语句，C语言的printf()等。 

(3) 标准出错输出(stderr)，缺省值为屏幕显示。 stderr的来源：C语言的fprintf(stderr,...)等

（个人觉得 ，一般这个输入和输出指的就只是字符）

键入^D 等于文件结束符 EOF

#### 改变stderr的定向

B shell/Bash 的格式为：**2> file**，表示将 stderr 的输出改为存入文件 file。 

例如，将 C 编译程序 cc 的出错信息存入文件 errfile，操作为： $ cc b.c 2> errfile 

**C shell 不能单独改变 stderr 的定向，只能合并 stdout 和 stderr。**



#### 合并stdout和stderr  

合并 stdout 和 stderr，表示将 stdout 和 stderr 指向同一个文件 file。 

B shell 的格式为：>file 2>file 

Bash 的格式为： >file **2>&1**  （个人觉得B shell不能合并，就是两步都写一下。bash则支持用&1省略file）

C shell 的格式为：>&file（C shell就是把必须>&）

#### 分界符（重要）

分界符(Here Document)通常用在 shell 程序中。

分界符的格式为：

command >file << InputFromHere 

input_msg  

InputsFromHere  

其中，command 是某个命令行的内容，InputFromHere 称为分界符，是用户定义的任何一个 字符串，input_msg 是前后两个分界符之间的若干行文字。 **分界符的功能是用 input_msg 替换 stdin 的输入**。 >file 的作用是改变 stdout 的定向，将 input_msg 写入文件 file。

![image-20240507224241997](.\image\image-20240507224241997.png)

#### 流水线操作

![image-20240507224555072](.\image\image-20240507224555072.png)

#### 替代符(注意与正则表达式不一样)

![image-20240507224923835](.\image\image-20240507224923835.png)

### shell变量（注意变量语法）

**普通变量** 普通变量是指由用户定义的变量，通常用小写字母表示。 

**环境变量** 环境变量可由系统设置或者用户定义。

环境变量不仅仅可在shell命令中引用，还可以在shell程序以及用户程序(例如C程序)中引用。 B shell/Bash的环境变量通常全部用大写字母表示。 C shell的环境变量通常全部用小写字母表示

![image-20240507225336800](.\image\image-20240507225336800.png)

![image-20240507225411633](.\image\image-20240507225411633.png)

![image-20240507225418662](.\image\image-20240507225418662.png)

![image-20240507225457616](.\image\image-20240507225457616.png)

由一对反引号“`”括起的命令，表示将命令执行的结果赋给变量。



B shell 的环境变量在定义之后还必须用 export 命令予以确认。

**在 C shell 中可以引用 B shell 的环境变量。 但是在 B shell 中不可引用 C shell 的环境变量。**



#### 最常用的环境变量

##### 注册目录

B shell 和 Bash ：HOME  

C shell  ：home

![image-20240507225728482](.\image\image-20240507225728482.png)



##### 可执行路径

**PATH**  定义 PATH 的分隔符为分号**“:”**  

**path**  定义 path 的分隔符为空格**“□”**

**可执行路径用于定义用户命令的所有执行路径**。除了常驻内存的 Linux 内部命令(built-in  command)，shell 将在 PATH/path 指定的目录下依次寻找所需执行的命令。

如果找不到该命令，将会显示出错信息：“command not found”。

通常建议将当前工作目录“.”**设定为可执行路径的首选**。 

假设在/bin 和/usr/bin 下存在同名的命令 xyz，如果执行命令： $ xyz  将执行/bin/xyz，因为/bin **优先**于/usr/bin



##### 待命符

**PS1** 一级待命符 **PS2** 二级待命符 

**prompt** 待命符

![image-20240507230457526](.\image\image-20240507230457526.png)

##### 当前 shell 环境

表示用户当前正在使用的 shell 解释程序的类别：B shell，Bash 或 C shell。 

SHELL 

shell

### 特殊字符（包含双引号等各种特殊字符含义，十分重要）

![image-20240507230513963](.\image\image-20240507230513963.png)

### Shell编程

#### shell程序的识别

![image-20240507232209921](.\image\image-20240507232209921.png)

#### 启动shell解释程序

![image-20240507232227078](.\image\image-20240507232227078.png)

#### 修改保护权限

![image-20240507232246549](.\image\image-20240507232246549.png)

#### shell程序的特殊变量（重要）

命令行参数 command、option 和 variable 可以作为 **shell 程序的特殊变量**，传递到 shell 程 序内部。

##### 命令行参数

![image-20240507232338387](.\image\image-20240507232338387.png)



##### 进程号(记$$)

$$        表示当前执行的进程号。 

由于进程号是唯一的，通常可用来命名临时文件，以免重名。



##### 进程状态码（记$？）

$? 前一进程(上个命令)执行的状态码(命令返回值)。 

$?的值为0表示进程执行成功，非0值表示进程失败。

![image-20240507233016476](.\image\image-20240507233016476.png)

#### shell语句

任何Linux的**shell命令、shell程序(脚本程序)、用户程序**，都可以作为shell语句。 

在shell程序或者shell命令中可以使用的shell语句包括： **输入语句、输出语句、运算语句、移位命令、控制语句(控制结构)以及其他语句**。

##### 输入语句(read)

输入语句的功能是从 stdin 读入变量 variable。语法形式为： read  variable    |   set  variable=$< 

##### 输出语句echo 

输出语句 echo 的功能是向 stdout 输出 info。

语法形式为： echo [option] info  其中，info 是变量 variable、字符串 string 以及两者的组合

option 的取值表示输出后禁止换行(不换行)。

##### 版本差异现象：略

##### 运算符

![image-20240507234055750](.\image\image-20240507234055750.png)

##### 运算语句（语法要记）

运算语句只能用于整型变量的运算。 

B shell(空格不能省略)  var=\`expr□expr1□□expr2`  

C shell(空格不能省略)  @□var□=□expr1□□expr2 

Bash还增加了以下几种形式的运算语句(空格可以省略)  

let var =expr1□□expr2 

let "var□=□expr1□□expr2"  

var=$((expr1□□expr2))  

((var□=□expr1□□expr2))  

其中，var是变量，expr1和expr2是表达式。

包括以下算术运算符： +(加)、-(减)、\*(乘)、/(整除)、%(整除取余，取模) 

![image-20240507235448907](.\image\image-20240507235448907.png)

##### 移位语句（shift）

移位语句用于改变命令行参量的数目和内容。 每执行一次shift语句，命令行参量的数目($#)减n，第i+n个参量成为第i个参量，**\$0不变，其余参 量依次类推**。 

n的缺省值为1。有的版本禁用n，这也是一种版本差异现象。 **移位语句通常与for或者while等控制结构联合使用。**

##### 其他语句

exit语句 在shell程序中表示结束shell程序，在shell命令行中表示撤消注册(登录)。 

break语句 结束循环 

continue语句 结束本次循环



#### 测试表达式（控制结构前知，比较复杂要记忆）

**控制结构的条件判别称为测试表达式**， 当测试表达式成立时为真(true)，否则为假(false)。

**注意`[]`和`expression`之间的空格**，这两个空格是必须的，否则会导致语法错误。[]的写法更加简洁，比 test 使用频率高

B shell/Bash  	[□expr□] 或 test□exp 

C shell 				 (□expr□)

test 命令有很多选项，可以进行**数值、字符串和文件**三个方面的检测。

##### 数值测试表达式

![image-20240508083411360](.\image\image-20240508083411360.png)

##### 字符串测试表达式

![image-20240508000449191](.\image\image-20240508000449191.png)

##### 文件测试表达式

![image-20240508000517014](.\image\image-20240508000517014.png)



#### 控制结构

##### if结构(语句)

![image-20240508080700194](.\image\image-20240508080700194.png)

##### for结构(语句)

for  index in var_list 

do

​	state

done



##### case/switch结构(语句)

case var in  

cond1 ) state1 ;;  

cond2 ) state2 ;;  

…  

\* ) state ;;  

esac  **不能省略行尾的两个分号**



##### while结构(语句)

B shell/Bash  

while [ expr ]  

do  

 	state

done



foreach i ( $*)

\> $i\$j 表示创建一个空文件，文件名是\$i\$j



##### Until结构(语句)

until是Bash提供的控制结构：

until [ expr]  

do  

​	state 

done



#### shell函数

函数是B shell/Bash提供的程序体。

##### **函数定义**

[function] name ()  

{  state }  

或者 

[ function ] name ( ) 

{  state }  

其中，function为关键字，可以省略。name为函数名。



##### **函数的调用**

name [real_para]        	 real_para为实参，可以省略。

函数的形参遵循shell特殊变量的用法，使用$*，$#，$1，$2等实现函数参数的传递。



##### **函数的参数传递**

![image-20240508090755332](.\image\image-20240508090755332.png)

##### 函数的生效和外部调用（注意外部调用）

一个函数在定义之后，不仅可以在定义函数的shell程序中调用，还可以在shell命令行或者其他 shell程序中调用，称为函数的外部调用。 

在外部调用函数之前，必须用.(dot)命令运行函数定义的文件shellfile，将其录入shell环境， 使之生效。例如 $ .   shellfile（**注意：是.   shellfile，而不能是./shellfile，./shellfile是运行一个文件**）也可以写为.   ./shellfile（这里的./shellfile是相对路径写法）

 getPasswd () 输入密码函数 

{  

stty -echo **关闭终端的回显功能** 

echo -n “enter password:□” **提示输入** 

read paswd **读取paswd(无回显)**  

echo “your passwd is [$paswd]” 显示paswd  

stty echo 打开终端的回显功能 

} 

![image-20240509102106565](.\image\image-20240509102106565.png)

![image-20240509102116185](.\image\image-20240509102116185.png)

```bash
dd if=/dev/tty bs=1 count=1 2>/dev/null

dd：命令的名称，用于转换和复制文件。

if=/dev/tty：if 表示输入文件，/dev/tty 是终端设备文件，代表当前用户的终端。

bs=1：bs 表示块大小（block size），这里设置为 1，意味着 dd 命令将一次读取一个字符。

count=1：表示复制的块的数量，这里设置为 1，意味着 dd 将只读取一个字符。

2>/dev/null：这是一个重定向操作，2 表示stderr（错误输出），> 是重定向操作符，/dev/null 是一个特殊的设备文件，它会丢弃写入其中的所有数据。所以，这会丢弃 dd 命令的错误输出。
```

#### shell的增强特征

##### 命令补齐tab(略)

##### 文件名补齐tab（略）

而启动文件名补齐时所按的制表符，可能改为连续按两次制表符，或者按逃逸键 ，或者连续按两次逃逸键ESC。

##### 假名alias

![image-20240509103337957](.\image\image-20240509103337957.png)

![image-20240509104549756](.\image\image-20240509104549756.png)

###### 假名的长期使用 

对一个用户来说，总是希望根据自己的喜好定义一些假名，而且以后一直可以使用。因此，应该 把所需要的假名定义在配置文件中，这样每次登录时后假名生效。

1. 配置文件~/.cshrc 中增加所需要的 alias 命令。

2.  增加一个配置文件~/.alias，写入所需要的 alias 命令，并且在配置文件~/.cshrc 中增加以下语句：

    if ( -r ~/.alias ) then  

   ​			source ~/.alias  

   endif 

##### 命令史history

Bash 和 C shell 设置了一个命令缓冲区(存储空间)，记录先前执行过的命令，并且提供了显示和引用这些命令的功能，称为**命令史机制**。

###### 命令史环境变量

![image-20240509113714454](.\image\image-20240509113714454.png)

这是C shell的如果用bash：

export HISTSIZE=6

export PS1='[\!]> '

###### 引用命令

**(1) 使用命令号引用命令缓冲区中的命令**

!n 				n 表示命令缓冲区中命令序号 

[7]> !1 		引用并执行第 1 条命令

**(2) 引用前一条命令。** 

!!  

[8]> !! 		引用并重复执行前一条命令

**(3) 使用相对命令号引用缓冲区中的命令。** 

!-n 				表示从当前命令号减去 n 得到的命令号 

[9]> !-4 		当前命令号是 9，!-4 表示引用第 5 条命令

**(4) 使用前导字符来匹配命令。格式为** 

!xxx 

**表示引用(匹配)缓冲区中最近执行的以字符串 xxx 为首的命令。** 

例如，用!v 引用的是以首字符 v 引导的第 4 条命令“vi main.c”。 

由于第 1，3，5，9 条命令都是以 c 为首字符，如果执行!c，表示引用最近的第 9 条命令。 如要引用第 3 条命令“cat main.c”，可将引用方式改为“!ca”：



**(5) 引用某条命令中的若干个参量。**

格式为 

命令:0 		命令名 

命令:* 		除命令名之外的所有命令行参量 

命令:^ 		命令中的第 1 个参量 

命令:$ 		命令中的最后 1 个参量

命令:n 		命令中的第 n 个参量  

命令:[n-m] 	命令中的第 n 到第 m 个参量

1. `!!`：代表整个上一条命令。
2. **`!$`：代表上一条命令的最后一个参数。**
3. `!:$`：代表上一条命令的最后一个字段（通常是命令的最后一个参数或命令的一部分）。



**(6) 在引用某条命令时，可以对命令的某个参量附加替换操作。** 

s/string1/string2 或者 s\^string1^string2 其作用是在引用的命令中将字符串 string1 改为 string2。 

[17]> cat /users/junk/doc/text  …  

[18]> **!17:s/doc/src**  

cat /users/junk/src/text  …  

表示将第 17 条命令中的字符串 doc 改为 src。

**(7) 显示而不执行某条命令。** 

命令:p  

[19]> **!17:p**  

cat /users/junk/doc/text  

表示仅仅显示第 17 条命令，但是并不执行该命令。

**(8) 引用命令中某个表示路径参量的前导目录。** 

命令:h  

[20]> cd **!17:^:h**  

cd /users/junk/doc  

第 17 条命令的首个参量**/users/junk/doc**/text 是一个路径，从中取出文件 text 的前导目录 /users/junk/doc，作为当前第 20 条命令 cd 的参量。

**(9) 引用命令中某个表示路径参量的最后一项(文件或者目录)。** 

命令:t  

[21]> mkdir **!20:^:t**  

mkdir doc  

表示将第 20 条命令中首个参量/users/junk/**doc** 的最后一项 doc 作为命令 mkdir 的参量。

**(10) 引用命令中某个参量的文件前缀。**

命令:r  

[22]> cc -c try.c  

[23]> cc -c sub.c  

[24]> cc -o **!22:$:r** try.o sub.o  

cc -o **try** try.o sub.o  

表示引用第 22 条命令中最后一个变量“try.c”的文件前缀“try”。



#####  工作目录栈

C shell 和 Bash 设置了一个工作目录栈， 并提供了相应的进栈和 出栈命令，用于方便切换曾经使用过的工作目录。 

假设用 Top 表示栈顶目录，Btm 表示栈底目录，Nxt 表示栈顶的下 一目录。只要栈非空，栈顶目录 Top 就是当前目录 Cwd(current working  directory)。

![image-20240509132038469](.\image\image-20240509132038469.png)

**进栈命令 pushd** 的格式为： 

pushd [dir] 

dir 为进栈目录。

工作目录栈**为空**时执行**无参数**的进栈命令 pushd，**执行失败**，系统报错。 

工作目录栈**非空**时执行**无参数**的进栈命令 pushd，**栈顶互换操作**：将栈顶目录 Top 与栈顶的下一目录 Nxt 互换。

**出栈命令 popd** 的格式为： 

popd  

如果工作目录栈为空，执行出栈操作将报错。 

出栈操作：删除栈顶目录 Top，栈顶的下一目录 Nxt 成为新的栈顶目录 Top。 如果栈中只有一个目录，出栈后工作目录栈为空。

**工作目录栈辅助命令 dirs** 的格式为： 

dirs  

显示工作目录栈，显示次序是栈顶目录在最左，然后依次向右，栈底目录在最右。

**工作目录栈辅助命令 cd** 的格式为：

cd [dir]  

执行 cd 命令的同时将栈顶目录 Top 改为目录 dir。 

如缺省 dir，表示 dir=$HOME。







# 第二章 Linux系统的软件开发工具

## Linux软件开发工具概述

### 文本编辑工具

Linux 系统提供了**三类文本编辑程序(文本编辑器**)：

**行文本编辑器、屏幕文本编辑器和字符流文本编辑器(非交互编辑器)。**

此外，有一些 Linux 命令(程序)也可用于文本的字符处理，它们是 一种**非专用的编辑器**

![image-20240509155919752](.\image\image-20240509155919752.png)

#### 行文本编辑器

ed是UNIX中最早开发最基本的文本编辑工具。UNIX开发之初，没有图形界面，就用ed来编辑操 作系统的各种源程序和文本文件。 

**ed**面向行文本，用户界面功能很弱，编辑时看不到上下文，使用起来很不方便。但是，ed提供 了此后开发的各种编辑工具中最底层的编辑函数，有助于其他诸多编辑器的学习。 

**vi(Visual display editor)**是UNIX最早开发的全屏文本编辑器。而且可以与行文本的编辑工具 **ex(ed的超集)相互切换**，使得这两个UNIX系统中元老级的文本编辑工具被广泛应用。 **vim(vi Improve)、gvim(面向全屏的vim)、emacs(Linux中vi的增强版本)**等各种后起之秀各具特 色，各具拥趸。

#### 流式编辑器

Linux把回车符也视为字符，因此一个多行文本的文件被视为一个字符流。sed和awk等流式编辑 器是使用事先确定的编辑命令，对文本文件实施全局性和快速的非交互式的编辑。 

适用于流式编辑器的情况为： 

(1) 有的文件行数太多或某些行的字符太多，超出全屏编辑器的缓冲区能容纳的限度。 

(2) 能够事先确定的以全局为主的编辑操作。 

(3) 编辑命令中字符数较多，如能事先确定则可避免在键入命令时出错。 

(4) **更多的情况是可以结合Linux的其他命令实现流水线操作。**



### 软件维护工具

软件编译和生成 make  

版本管理工具  版本控制系统(Version Control System, VCS)包括SCCS，RCS，SVN，CVS， Git等。 

库函数管理 ar(archive)等

###  编译器生成工具

编译器生成工具 (compiler generation)是编写词法语法编辑器的辅助工具。 

词法编译器生成工具 **lex**(lexical generation)  

语法编译器生成工具 **yacc**(yet another compiler compiler)  

形式化描述语言 **BNF范式**(Backus Naur Form，BACKUS系统)，可用于描述文本文件的语法和词法结构。





## vi

### 启动vi的方式 

vi [file [...] ] 对0到多个文件file进行编辑 

例如，vi a.txt 编辑文件a.txt  			例如，vi a.txt b.txt 逐个编辑文件a.txt和b.txt 



vi的空白窗口中，左侧一列显示~，表示空行。 

如果编辑**无名文件**，则可能显示帮助信息。编辑后**需另存文件**。 

如果编辑**新文件**，则底行**显示文件名及[New file]**。



设置光标 

通过对终端特性的设置，可以选择光标采用块状或者下划线形式。还可以选择是否闪烁。

### vi的工作状态及其切换（问题:Q不生效）

vi有三种工作状态：**vi状态、ex状态以及不常用的open状态**。  

vi状态有两种工作模式：**命令模式和插入模式**。 命令模式、插入模式以及ex状态之间可以相互切换。



ex状态 

ex状态，又可称为ex模式或者底行模式。 从shell中启动ex，即 $ ex [file [...] ]  ex状态的特征是在vi窗口的底行显示待命符“:”

![image-20240509163127332](.\image\image-20240509163127332.png)

（问题:Q不生效）

### vi的工作方式

 **vi的输入 ：**

从外存(通常是硬盘)将文本文件xfile读入到内存的编辑工作区(缓冲区)，成为内存文件。如果 编辑一个新文件，则省略输入操作。

vi的输出 内存文件输出到硬盘。或者按原文件名xfile存放，或者另存为文件yfile

![image-20240509163754350](.\image\image-20240509163754350.png)

### 编辑对象及定位

##### 编辑对象

词word(狭义单词)  由**字母、数字和下划线组成，或者由标点符号组成**。 

词WORD(广义单词)  由**非空字符组成，空字符作为WORD的分隔符**。 

例如： 2004_Mar_1 表示1个word，或者1个WORD  

2004-Mar-1 表示5个word，或者1个WORD  

%d%d,n,m 表示8个word，或者1个WORD  

**%d+->%d12 表示4个word**，或者1个WORD

结合词(组合词)  词首，词尾，前n个词，后n个词 

行 当前行，上一行，下一行，第n行，首行(文件第一行)，尾行(文件最后一行)  

文件 当前(正在编辑的)文件，输入文件，输出文件，下一文件

##### 定位命令

![image-20240509181145303](.\image\image-20240509181145303.png)

### 输入类命令（:n, :e, :r要记，不太记得）

![image-20240509181730997](.\image\image-20240509181730997.png)

###  输出类命令（:u,vw file）

![image-20240509182712052](.\image\image-20240509182712052.png)

### 退出类命令(ZZ)

![image-20240509183236620](.\image\image-20240509183236620.png)

### 插入类命令(iao)

![image-20240509183248445](.\image\image-20240509183248445.png)

### 替代命令(重要！记不清)

![image-20240509183801181](.\image\image-20240509183801181.png)

ns表示将包含当下字符向后n个字符都删除，并进入插入模式

cw表示将包含当下字符向后1个word删除，并进入插入模式

###  删除类命令（替代命令进入插入模式，删除命令直接删除）

#### 字符删除命令

![image-20240509184421531](.\image\image-20240509184421531.png)

#### 行删除命令

![image-20240509184607302](.\image\image-20240509184607302.png)

感觉这个dnG取决于nG和当前行位置，最终效果就是nG和当前行之间的行都被删除

### 搜索命令（注意正则表达式）

![image-20240509184836966](.\image\image-20240509184836966.png)

实际上，??或者//会被替换为上一次使用//的命令

![image-20240509185102859](.\image\image-20240509185102859.png)

`\S` 是一个特定字符类，它匹配任何非空白字符

相对地，小写字母 `s` 在正则表达式中通常用来匹配任何单个空白字符，包括：

- 空格
- 制表符
- 换行符
- 回车符

### 全局替代命令

注意，全局替换命令的pattern和搜索命令的缓存是一样的，全局搜索之后，他的pattern在//时会将//换为全局替换时候的pattern

![image-20240509185940305](.\image\image-20240509185940305.png)

含有字符串 pattern 的行称为为匹配行。

addr1[,addr2]表示匹配行的地址范围是从 addr1 到 addr2 的之间的行。

省略 addr2 表示仅匹配 addr1 表示的行。**addr1 和 addr2 可以采用与 pattern 相同的字符串匹配方式，还可采用行号表达的行地址**。例如，**“1,/^#/”表示匹配行的范围 从第 1 行到首次出现行首为“#”的行。** （也可以/Start/,/End/    表示匹配从含有Start到含有End的行）

感叹号“!”表示不含 pattern 的行为匹配行。**修饰字符 g 表示搜索所有的匹配行**，**省略 g 表 示仅搜索第一个匹配行。**

全局替代命令表示在匹配行内将字符串 str 改为字符串 new_str。**如果 str 与 pattern 相 同，可以省去 str**。

（注意：如果pattern省略，那么会将\\\默认替换为上一次的pattern命令，就是缓冲区内的查找字符串）（于是你可以g//s/str/newstr/gp也可以g//s//newstr/gp还可以g/pattern/s//newstr/gp）

![image-20240509190702975](.\image\image-20240509190702975.png)

(g在前面是表明搜索所有的匹配行，g在后面表示搜索所有匹配行中的所有str并全部替换)

### 全局删除命令

全局删除命令又称为 d 命令(delete line)，命令形式为 

:[g[!]]/pattern/d 或者 

:addr1[,addr2]d

### 无名宏和有名宏（&）

搜索字符串 pattern 总会保存在 **vi 的搜索缓冲区内**，并且可以在 new_str 中**用符号&引用缓 冲区中的字符串。这种引用方式称为无名宏**。

例如， :g/printf(/s//fprintf(stderr, /g

在 vi 中，无名宏只有一个。**可以定义若干个有名宏以实现在一个全局替代命令中多次保存和引 用字符串的功能**。如果将 pattern 或者 str 中的某个字符串定义为一个有名宏，应该将这个字符 串用“\\(”和“\\)”括起。此后再用“\d”调用已定义的有名宏。d 是一个数字，表示宏的名字。根 据有名宏定义的先后顺序，依次用“\1”、“\2”等等来调用有名宏。

### 块操作命令

vi提供三个基本的动作：pick(拾取)，cut(剪取)和put(粘贴)。  由此完成按块(block)复制(copy)和移动(move)功能。 

其中， copy = pick + put  move = cut + put  

以**字符(char)、词(word或WORD)为单位或者以行(line)为单位均可组成块**。 

块操作的内容存放在缓冲区内：一个**无名缓冲区**，以及**若干个用户命名的有名缓冲区**。



pick：\["x][n]yw 或\["x][n]yW 拾取 n 个词(包括后空格)存入缓冲区。 

pick：\["x][n]yy 拾取包含当前行在内的 n 行存入缓冲区。 

cut：  \["x][n]dd 剪取含当前行在内的 n 行存入缓冲区。 

put：  ["x]p 或["x]P 粘贴缓冲区内容

(这里的y和d也支持yj表示本行和上行，yk表示本行和下行，dj,dk同理)

若块的内容**以行为单位**，则**向下(p)或者向上(P)**粘贴。 

若块的内容**以字符为单位**,则**向右(p)或者向左(P)**粘贴。

 其中，y 是 yank(移出)的缩写。**n 缺省为 1。** 

可用**字符 x 命名有名缓冲区**，省略 x 表示无名缓冲区。 

**已经介绍过的删除类命令都可以作为剪取命令。**



**ex块**操作命令 

copy： **:**u[,v]**co**k  				将第 u 行到第 v 行复制(copy)到第 k 行之下。 

move： **:**u[,v]**m**k  				将第 u 行到第 v 行移(move)到第 k 行之下。 

其中，省略 v 表示只对第 u 行实施复制或者移动。

### 杂类命令

**. 		 重复执行编辑类命令(插入、删除和替代命令)。** 

u 		**撤消**刚才执行的编辑类命令, **或恢复刚才撤消的命令**（ctrl + r）。 

^L 			控制键 CRTL+L，**刷新屏幕。**

 **J 			将下一行连到本行尾，等价于将换行符改为空格。** 

:!cmd 	执行 1 个 shell 命令 cmd，随后返回 vi。 

**:sh 		转到 shell 状态，将显示 shell 的待命符，以便执行 shell 命令， 结束时需要用 				exit 命令返回 vi。**

例如，将文本中的 fi 替换为 endif，重复执行替换的命令过程为： 

/fi⊕ 				搜索 fi(省略了第二个斜杠/)，等价于/fi/  

2sendif 			用 endif 替代两个字符 fi(2s 和不显示)  

n 						搜索下一个 fi  

. 						再次执行替换操作 又例如，执行 J 命令后合并两行，将第一行的换行符改为空格。







## sed

sed(Streamer Editor)是一个**非交互式**的文本编辑程序(**字符 流**编辑程序，**流式编辑器**)。

### **sed用法**

sed 'command ' [file ]  表示对输入文件 file 执行 sed 命令 command。 

或者 sed -f sfile [file ]  表示执行由-f 指定的 sed 命令文件 sfile 中的若干个 sed 命令。



sed 的**输出指向标准输出**。如果缺省 file，sed 的**输入取自标准输入**。 

sed 可以在 shell 命令行中执行，也可以作为 shell 程序的命令语句。 

例如，在 shell 命令行中执行以下 sed 命令： 

\$ sed '1d'  \<file >tmpfile 			删除 file 中的第一行 

$ sed 's/a/b/' \<tmpfile 				将 tmpfile 中文本中的字符 a 替换为 b 

![image-20240509202231413](.\image\image-20240509202231413.png)

### sed的工作流程

如果有多条 sed 命令，sed 采用流水线方式逐条执行命令的工作流程。针对输入文本，每执行 一条 sed 命令，将生成一个内部的中间文本，传递给下一条 sed 命令，直至最后生成输出文件。

### sed的命令格式 

[pattern] [!] function [argu]

表示用 sed 命令 function 处理由地址表达式 pattern 匹配的行，并且执行辅助功能 argu。 如果缺省 pattern，表示对所有行执行 function。 如果加!，表示对不匹配pattern的行执行function。 

由于 **sed 的许多基本操作也是由 ed 程序的函数实现的，因此 sed 的 pattern 和 function 均与 vi 的全局操作命令相同**

![image-20240509202645315](.\image\image-20240509202645315.png)



 sed命令行可选项**-n**的作用是**仅仅输出匹配行的内容**。 (这句话并不准确)

sed -n 'command ' [file] 

或者 sed -nf sfile [file] 

\$ sed -n '3,4d' text >b.txt  

$ cat b.txt  			  文件 b.txt 为空



在 `sed` 中：

- `-n` 选项通常用来抑制默认输出，即不显示处理后的结果，除非你明确告诉它要打印某些行。
- `'3,4d'` 是一个地址范围和删除命令的组合，意味着删除从第三行到第四行的内容。

然而，结合 `-n` 和 `'3,4d'` 会导致一些不符合预期的行为，因为 `-n` 抑制了所有行的输出，而 `'3,4d'` 只是删除行而不打印它们。如果你想要删除文件中的第三行和第四行，并且不显示任何输出，你不需要 `-n` 选项，因为 `d` 命令本身就不会输出被删除的行。



### **无名宏**和有名宏（略）

课本上面有示例

### 块操作命令（重要，不会，涉及Hold区和Pattern区）

在 sed 中实现块操作需要使用两个缓冲区：Pattern 区和 Hold 区。 Pattern 区存放匹配行的内容，简称匹配行。Hold 区是编辑匹配行时使用的临时缓冲区。 涉及块操作的命令及功能如下：

![image-20240509214359561](.\image\image-20240509214359561.png)



示例：

![image-20240509214646129](.\image\image-20240509214646129.png)

1. `h`：这个命令将当前的模式空间（pattern space，也就是当前正在处理的行）复制到保持空间（hold space）。
2. **`n`：这个命令读取下一行文本到模式空间，替换掉当前的内容**。（N会追加）（注意n可能会影响sed流处理的逻辑）
3. `p`：这个命令打印模式空间的内容，也就是刚刚读入的下一行。
4. `x`：这个命令交换模式空间和保持空间的内容。
5. `p`：再次打印模式空间的内容，此时模式空间中是上一行的内容，因为刚刚执行了交换

刚开始默认读取下一行

###  网表文件转换程序示例：c2n（略）见讲义





## BNF范式

BNF 范式(Backus Naur Form，巴克斯范式)，是一种**针对计算机语言的形式化描述语言**，或者 说是**一种描述计算机语言语法的符号集**

计算机面对任何形式的字符流或者命令流，都可以看成是具有 一定语法和词法规则的语言。 

这种语言可以是文字形式，例如各种输入的数据文件或者文本 文件、用 shell 命令或者 shell 程序表达的操作命令。也可以是图 形界面形式，例如在窗口中用菜单命令表达的操作命令。 

BNF 范式可用来描述任何一种形式化语言的语法词法结构。

###  BNF范式的定义

设**∑**是**不含有**符号::=，<，>和|的**终结符(字符)集合**； 

用括号< >括起来的终结符的组合，称为**变量V;**  

终结符和变量的组合称为**字W;**  

形为V ::= W1 | W2 | ... | Wn的表达式称为**产生式**;  

**终结符是不可推导的最小元素，不能单独出现在表达式左边。** 

**不是终结符的都是非终结符**，必须出现在表达式左边加以描述。 

由**有限个产生式组成的系统称为BNF范式**。

![image-20240509232627437](.\image\image-20240509232627437.png)



### BNF范式的特征

BNF 范式具有描述形式化语言的三种基本特征：顺序性、选择性和重复性

**顺序性：**  按确定的次序定义产生式中的成分。 

例如，由 A、B 和 C 的顺序排列组成 X，描述为： 

X ::= A B C

**选择性**：  产生式可以从多个可能的成分中选一个，用符号“|”表示连接。 

例如，X 的组成可能是 A 和 B 中的一个，描述为： 

X ::= A | B  特别地，A 可以是空，即可以表述为： 

X ::= | B

**重复性：**  

产生式可以由某个成分的多次重复组成，采用递归的形式表示。 

例如，X 由多个 A 组成，描述为： 

**X ::= A | X A 左递归**(推荐使用)  或者 

**X ::= A | A X 右递归**

（重点是|保证了递归不会无限递归）



### BNF范式示例（略，见讲义）

![image-20240509233218016](.\image\image-20240509233218016.png)



## awk

awk也是一个流式编辑程序，除了与sed类似的编辑功能，**awk还提供了简单的变量操作和控制 结构**，使得特定数据的选择和变换操作更易于表达。

### awk的用法

awk 'program' [file]  

表示按照 awk 程序 program 对输入文件 file 逐行扫描处理。 

或者 

awk –f pfile [file]  

表示按照-f 指定的 awk 程序文件 sfile 对输入文件 file 逐行扫描处理。 

其中，program 和 pfile 都可以含有若干个 awk 命令。 

awk 的输出指向 stdout。如果缺省 file，awk 的输入取自 stdin。



### awk的工作流程

![image-20240509234920158](.\image\image-20240509234920158.png)



###  记录、字符段和特殊变量（注意：所有符号都是变量，除非加“”）

awk将文本文件定义为若干个记录(record)组成的字符流。 

每个记录由若干个字符段(field)组成，每个字符段是由非空字符组成的字符串。 

以下是awk提供的一些常用的特殊变量： 

**NR**： 每个记录的序号(number of record)。

**NF**： 每个记录中字符段的数目(number of field)。 **依次用特殊变量$1，$2，…表示各个字符段。$0表示整个记录。**

**RS**： 记录分隔符(record separator)。缺省值为换行符。 

**FS**： 字符段分隔符(field separator)。缺省值为空格或制表符。 

**FILENAME**： 输入文件名(不能在BEGIN模式中使用)  

因此，在缺省的情况下，每个记录就是一行，最后一行的行号就代表文件的行数。



### 变量及运算

awk程序中的变量可以是数字型或者字符型，**数字型变量的计算按浮点数处理**。

**变量名可以用除了特殊变量之外的任何字符来定义，并可随时引用变量。变量的初值为零或空 字符**。



awk提供各种运算操作： 包括算术运算、关系运算和逻辑运算等。 

awk运算符与C语言的运算符是一样的： 

算术运算符有+、-、*./、%(取模)、++和--。 

关系运算符有>、<、>=、<=、==和!=。 

逻辑运算符有&&、||和!。 

赋值运算符有=、+=，-=、*=、/=和%=

变量的引用可以用数字表达式表示。 

例如，**当i和n都是已知数时，可以使用、**\$(i+1)，$(i-n)等表达式。 

在运算表达式中，如果将分隔各字符段/变量的逗号改为空白符，表示字符段/变量的串接操作。



### awk程序的匹配模式

#### awk的程序结构

![image-20240510005348549](.\image\image-20240510005348549.png)

patn1 和 patn2 可以采用**字符串匹配模式、组合模式和专用模式匹配模式**

patn1 [, patn2]  表**示由 patn1 和 patn2 确定匹配行**(patn1和patn2之间的行)。 缺省 patn2 时，表示由 patn1 确定匹配行。

#### 字符串匹配模式

var ~ /string/  

表示某个**字符段 var** 中**含有字符串 string** 的行是匹配行。 

var !~ /string/  

表示某个字符段 var 中**不含字符串 string 的**行是匹配行。 

**var 表示的是字符段\$0，\$1，$2 等。** 

/string/				 等价为 			$0 ~ /string/

表示含有字符串 string 的行是匹配行。 

string 的用法除了与 vi 中对字符串的定义相同之外，还可以使用以下方式： 

x|y 表示匹配字符串 x 或者字符串 y。 

x+ 表示对字符 x 的一次或多次重复。 

x? 表示对字符 x 的零次或多次重复。



输出含有字符串 start 到含有 stop 之间的行： 

$ awk '**/start/, /stop/**' text

#### 组合模式

组合模式是指各种运算（算术运算、关系运算和逻辑运算）的组合。

![image-20240510094333253](.\image\image-20240510094333253.png)

#### 专用模式

BEGIN和END是可选的两个专用模式，它们与各行的匹配模式无关，格式为： 

BEGIN {action} 在处理所有文本行之前执行action。

END {action} 在处理所有文本行之后执行action。

### awk语句

一个操作action可由多个awk语句组成，各语句之间用**分号隔开**。

**最后一个语句或者只有一个 语句可以省略分号**。 awk语句包括打印语句和赋值语句。

#### 打印语句

awk提供的打印语句有print和printf。

格式为： 

print [expr, …]  按自由格式打印若干个参量expr，各参量之间自动加空格，**最后加换行符**。省略expr时，打印 整行。 

printf "format", [expr, …]  C语言中的printf作用相同。每一个表达式expr的格式由format中用百分号%引起的格式说明 符表示，例如%d表示打印整数，%s表示打印字符串等等。

（注意：printf不会自动加换行符）



{printf ”file %s\n", \$1>“f1”; print \$2>\$3}  表示使用shell的输出定向。将\$1输出到文件f1，将\$2输出到名为$3的文件。(注意这里的f1需要前后加“”)



#### 赋值语句（没有赋值的任何字符第一次为0）

赋值语句的形式为： var = expr 

其中，var是任何一种变量或数组元素。var的类型由实际操作的情况而定。

expr是算术表达 式。**运算符两侧必须加空格，而不能连写。**(注意：没有赋值的任何字符，第一次作为数值使用默认为0)

![image-20240510102919901](.\image\image-20240510102919901.png)

#### 数组

awk 允许**随意使用数组。不需要定义，也不需要初始化，可根据实际情况而定**。

数组元素的下 标可以是**非零**数字或**非空字符串**。 

例如，使用一个数组，取名为 fruit。数组元素的下标用字符串 apple 和 orange 表示。统计含有 字符串 apple 和 orange 的行数，结束后打印结果。其 awk 程序为

####  常用内部函数(一些关键字)

 length[(var)] 		相当于C语言的函数strlen(str)  

sqrt(var)  

log(var)  

exp(var)  

int(var)  

例如： 

length(\$1) > length(\$2) 			比较\$1与\$2中的字符数 

{ print length(\$1 \$2) } 				打印\$1与$2串接后的字符数 

{ print length } 							打印一行中的字符总数 length等价于length(\$0) 



#### 控制结构

![image-20240510104116709](.\image\image-20240510104116709.png)

![image-20240510104306717](.\image\image-20240510104306717.png)

主要关注最后一个关于**数组运用**的例子



## make

### 描述文件

##### 依赖关系(递推规则，隐式执行)

依赖关系的涵义为 if(dependent \<NT> target)   NT表示 newer-than  

command 表示如果 target 不存在或者 dependent 在 target 之后有了新版本，  就需要执行 command 来生成 target。

![image-20240510105552250](.\image\image-20240510105552250.png)

make 的语法规定，command 一行的**行首必须使用制表符，而不能使用空格。**

![image-20240510105637553](.\image\image-20240510105637553.png)

![image-20240510105706134](.\image\image-20240510105706134.png)

由#引导是注释 comment。@表示执行命令而不显示命令。 

make 的语法规定，**command 一行的行首必须使用制表符\<TAB>，而不能使用空格**

**注意没有dependent时候用:;**



**隐式执行命令**

![image-20240510105816940](.\image\image-20240510105816940.png)

如果**缺省@，表示先显示命令后再执行命令**。**如果加@，表示执行命令而不显示命令**。 



描述文件  

使用make，需要建立一个**描述文件，以表述所有的依赖关系(常用的描述文件为makefile)， 并据此执行相关的命令。**

### 宏定义和特殊变量(\$@和$^)

![image-20240510110515332](.\image\image-20240510110515332.png)

#### 特殊变量\$@和$^

特殊变量**\$@** 表示依赖关系中的目标文件 **target，**

特殊变量**$^** 表示依赖关系中的所有依赖文件 **dependent。**

### 后缀定义和传递规则(重要)

#### 传递规则

根据Linux文件的后缀定义，可用**传递规则**来描述依赖关系。

![image-20240510110743057](.\image\image-20240510110743057.png)



#### 后缀规则（\$<,$*）

  ![image-20240510110822149](.\image\image-20240510110822149.png)

#### 后缀定义(.SUFFIXES)

**SUFFIXES语句用于描述传递规则中的后缀定义**，描述格式为 

.SUFFIXES: .x.y 

表示.x依赖文件与.y目标文件之间存在依赖关系。 由于.c和.o都是Linux文件的标准后缀，因此可省略SUFFIXES语句





###  make命令行

make命令行的完整用法为 

make [flag] [macro] [target]  

可选项 flag、宏定义 macro 和目标 target 三个参量均可省略。

![image-20240510112252607](.\image\image-20240510112252607.png)

**宏定义macro** 

使用宏定义macro的格式为： 
\$ make macro=variable 表示将覆盖描述文件中定义的宏。 

例如，描述文件makeB中定义了如下的宏： TASK = tst  

如果启动make的命令为： $ make TASK=mytask  表示生成的可执行文件将是mytask，而不再是tst。